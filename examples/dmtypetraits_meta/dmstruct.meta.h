/********************************************************************
** This head file is generated by program,                 **
** Please do not change it directly.                   **
********************************************************************/
// source: dmstruct.pkg

#ifndef __DM_META_DMSTRUCT_H__
#define __DM_META_DMSTRUCT_H__

#include <tuple>
#include <utility>
#include <string>

// Include dmcast and the intrusive reflection header to use their tools
#include "dmtypetraits.h"
#include "dmcast.h"

#include "dmstruct_test.h"

// Forward declaration of the lexical_cast for cross-use
namespace dmcast {
    template <typename To, typename From>
    typename std::enable_if<!std::is_same<To, From>::value, To>::type
    lexical_cast(const From &from);
}

namespace dm {
namespace refl {

// Base template for reflection traits
template<typename T>
struct traits {
    static constexpr bool is_reflected = false;
};

// Reflection traits specialization for MyStruct
template<>
struct traits<MyStruct> {
    static constexpr bool is_reflected = true;
    static constexpr const char* name = "MyStruct";

    constexpr static auto members() {
        return std::make_tuple(
            std::make_pair("foo", &MyStruct::foo),            std::make_pair("bar", &MyStruct::bar)        );
    }
};
// Reflection traits specialization for Metadata
template<>
struct traits<Metadata> {
    static constexpr bool is_reflected = true;
    static constexpr const char* name = "Metadata";

    constexpr static auto members() {
        return std::make_tuple(
            std::make_pair("author", &Metadata::author),            std::make_pair("timestamp", &Metadata::timestamp)        );
    }
};
// Reflection traits specialization for ComplexData
template<>
struct traits<ComplexData> {
    static constexpr bool is_reflected = true;
    static constexpr const char* name = "ComplexData";

    constexpr static auto members() {
        return std::make_tuple(
            std::make_pair("id", &ComplexData::id),            std::make_pair("status", &ComplexData::status),            std::make_pair("metadata", &ComplexData::metadata),            std::make_pair("properties", &ComplexData::properties),            std::make_pair("sensor_readings", &ComplexData::sensor_readings)        );
    }
};

} // namespace refl
} // namespace dm

// Provide specializations for dmcast to handle reflected structs
namespace dmcast {
// Converter specialization to convert MyStruct to std::string
template<>
struct Converter<std::string, MyStruct>
{
    static std::string convert(const MyStruct& from)
    {
        std::string result = "{";
        bool first = true;
        // Use the reflection utility to visit members
        dm::refl::dm_visit_members(from, [&](const char* name, auto&& value) {
            if (!first) {
                result += ",";
            }
            // Format as "name":value
            result += "\"";
            result += name;
            result += "\":";
            // Recursively call lexical_cast to convert member's value to string
            result += dmcast::lexical_cast<std::string>(value);
            first = false;
        });
        result += "}";
        return result;
    }
};
// Converter specialization to convert Metadata to std::string
template<>
struct Converter<std::string, Metadata>
{
    static std::string convert(const Metadata& from)
    {
        std::string result = "{";
        bool first = true;
        // Use the reflection utility to visit members
        dm::refl::dm_visit_members(from, [&](const char* name, auto&& value) {
            if (!first) {
                result += ",";
            }
            // Format as "name":value
            result += "\"";
            result += name;
            result += "\":";
            // Recursively call lexical_cast to convert member's value to string
            result += dmcast::lexical_cast<std::string>(value);
            first = false;
        });
        result += "}";
        return result;
    }
};
// Converter specialization to convert ComplexData to std::string
template<>
struct Converter<std::string, ComplexData>
{
    static std::string convert(const ComplexData& from)
    {
        std::string result = "{";
        bool first = true;
        // Use the reflection utility to visit members
        dm::refl::dm_visit_members(from, [&](const char* name, auto&& value) {
            if (!first) {
                result += ",";
            }
            // Format as "name":value
            result += "\"";
            result += name;
            result += "\":";
            // Recursively call lexical_cast to convert member's value to string
            result += dmcast::lexical_cast<std::string>(value);
            first = false;
        });
        result += "}";
        return result;
    }
};
} // namespace dmcast


#endif // __DM_META_DMSTRUCT_H__