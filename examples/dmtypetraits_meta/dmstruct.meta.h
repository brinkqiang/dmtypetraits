/********************************************************************
** This head file is generated by program,                 **
** Please do not change it directly.                   **
********************************************************************/
// source: dmstruct.pkg

#ifndef __DM_META_DMSTRUCT_H__
#define __DM_META_DMSTRUCT_H__

#include "dmtypetraits.h"
#include "dmcast.h"

#include "dmstruct_test.h"

namespace dm {
namespace refl {

// Reflection traits specialization for MyStruct
template<>
struct traits<MyStruct> {
    static constexpr bool is_reflected = true;
    static constexpr const char* name = "MyStruct";

    constexpr static auto members() {
        return std::make_tuple(
            std::make_pair("foo", &MyStruct::foo),            std::make_pair("bar", &MyStruct::bar)        );
    }
};
// Reflection traits specialization for Metadata
template<>
struct traits<Metadata> {
    static constexpr bool is_reflected = true;
    static constexpr const char* name = "Metadata";

    constexpr static auto members() {
        return std::make_tuple(
            std::make_pair("author", &Metadata::author),            std::make_pair("timestamp", &Metadata::timestamp)        );
    }
};
// Reflection traits specialization for ComplexData
template<>
struct traits<ComplexData> {
    static constexpr bool is_reflected = true;
    static constexpr const char* name = "ComplexData";

    constexpr static auto members() {
        return std::make_tuple(
            std::make_pair("id", &ComplexData::id),            std::make_pair("status", &ComplexData::status),            std::make_pair("metadata", &ComplexData::metadata),            std::make_pair("properties", &ComplexData::properties),            std::make_pair("sensor_readings", &ComplexData::sensor_readings),            std::make_pair("metadatas", &ComplexData::metadatas)        );
    }
};

} // namespace refl
} // namespace dm

namespace dmcast {
// Converter specialization to convert MyStruct to std::string
template<>
struct Converter<std::string, MyStruct>
{
    static std::string convert(const MyStruct& from)
    {
        std::string result = "{";
        bool first = true;
        dm::refl::dm_visit_members(from, [&](const char* name, auto&& value) {
            if (!first) {
                result += ", ";
            }
            result += "\"";
            result += name;
            result += "\": ";
            result += dmcast::lexical_cast<std::string>(value);
            first = false;
        });
        result += "}";
        return result;
    }
};
// Converter specialization to convert Metadata to std::string
template<>
struct Converter<std::string, Metadata>
{
    static std::string convert(const Metadata& from)
    {
        std::string result = "{";
        bool first = true;
        dm::refl::dm_visit_members(from, [&](const char* name, auto&& value) {
            if (!first) {
                result += ", ";
            }
            result += "\"";
            result += name;
            result += "\": ";
            result += dmcast::lexical_cast<std::string>(value);
            first = false;
        });
        result += "}";
        return result;
    }
};
// Converter specialization to convert ComplexData to std::string
template<>
struct Converter<std::string, ComplexData>
{
    static std::string convert(const ComplexData& from)
    {
        std::string result = "{";
        bool first = true;
        dm::refl::dm_visit_members(from, [&](const char* name, auto&& value) {
            if (!first) {
                result += ", ";
            }
            result += "\"";
            result += name;
            result += "\": ";
            result += dmcast::lexical_cast<std::string>(value);
            first = false;
        });
        result += "}";
        return result;
    }
};
} // namespace dmcast


#endif // __DM_META_DMSTRUCT_H__